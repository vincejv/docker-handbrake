From c7220594c5a126e40f1f70312b4d8793ae19278c Mon Sep 17 00:00:00 2001
From: Damiano Galassi <damiog@gmail.com>
Date: Mon, 18 Mar 2024 14:32:55 +0100
Subject: [PATCH] libhb: refactor how extradata is stored, use a dynamic heap
 allocated buffer instead of a small static one. Some codecs like FFV1
 requires up to 500 KB of extradata.

---
 libhb/common.c                    | 116 +++++-----
 libhb/decavcodec.c                |   9 +-
 libhb/decavsub.c                  |   9 +-
 libhb/decsrtsub.c                 |   7 +-
 libhb/decssasub.c                 |   7 +-
 libhb/dectx3gsub.c                |   7 +-
 libhb/enc_qsv.c                   |  39 ++--
 libhb/encavcodec.c                |   7 +-
 libhb/encavcodecaudio.c           |  13 +-
 libhb/enctheora.c                 |  16 +-
 libhb/encvorbis.c                 |  26 +--
 libhb/encx264.c                   |  21 +-
 libhb/encx265.c                   |  10 +-
 libhb/handbrake/common.h          |  25 ++-
 libhb/handbrake/hbtypes.h         |   2 +-
 libhb/handbrake/internal.h        |  52 +----
 libhb/muxavformat.c               | 337 +++++-------------------------
 libhb/platform/macosx/encca_aac.c |  15 +-
 libhb/platform/macosx/encvt.c     |  30 ++-
 libhb/rendersub.c                 |  19 +-
 libhb/stream.c                    |  34 ++-
 libhb/work.c                      |  16 +-
 22 files changed, 280 insertions(+), 537 deletions(-)

diff --git a/libhb/common.c b/libhb/common.c
index b610c3c05..ece86cbc7 100644
--- a/libhb/common.c
+++ b/libhb/common.c
@@ -15,6 +15,7 @@
 
 #include "handbrake/handbrake.h"
 #include "handbrake/hbffmpeg.h"
+#include "handbrake/extradata.h"
 #include "x264.h"
 #include "handbrake/lang.h"
 #include "handbrake/common.h"
@@ -3904,6 +3905,58 @@ hb_list_t *hb_string_list_copy(const hb_list_t *src)
     return list;
 }
 
+hb_data_t * hb_data_init(size_t size)
+{
+    hb_data_t *data = av_mallocz(sizeof(hb_data_t));
+    if (data == NULL)
+    {
+        goto fail;
+    }
+
+    data->bytes = av_mallocz(size);
+    if (data->bytes == NULL)
+    {
+        goto fail;
+    }
+
+    data->size = size;
+    return data;
+
+fail:
+    hb_data_close(&data);
+    return NULL;
+}
+
+void hb_data_close(hb_data_t **data)
+{
+    if (data == NULL || *data == NULL)
+    {
+        return;
+    }
+
+    if ((*data)->bytes)
+    {
+        av_freep(&(*data)->bytes);
+    }
+
+    av_free(*data);
+    *data = NULL;
+}
+
+hb_data_t * hb_data_dup(const hb_data_t *src)
+{
+    if (src == NULL)
+    {
+        return NULL;
+    }
+
+    hb_data_t *data = hb_data_init(src->size);
+    if (data)
+    {
+        memcpy(data->bytes, src->bytes, src->size);
+    }
+    return data;
+}
 
 int global_verbosity_level; //Necessary for hb_deep_log
 /**********************************************************************
@@ -4338,6 +4391,8 @@ static void job_clean( hb_job_t * job )
         free(job->file);
         job->file = NULL;
 
+        hb_data_close(&job->extradata);
+
         // clean up chapter list
         while( ( chapter = hb_list_item( job->list_chapter, 0 ) ) )
         {
@@ -5187,6 +5242,7 @@ hb_audio_t *hb_audio_copy(const hb_audio_t *src)
         {
             audio->config.in.name = strdup(src->config.in.name);
         }
+        audio->priv.extradata = hb_data_dup(src->priv.extradata);
     }
     return audio;
 }
@@ -5224,6 +5280,7 @@ void hb_audio_close( hb_audio_t **audio )
 {
     if ( audio && *audio )
     {
+        hb_data_close(&(*audio)->priv.extradata);
         free((char*)(*audio)->config.in.name);
         free((char*)(*audio)->config.out.name);
         free(*audio);
@@ -5343,10 +5400,9 @@ hb_subtitle_t *hb_subtitle_copy(const hb_subtitle_t *src)
     {
         subtitle = calloc(1, sizeof(*subtitle));
         memcpy(subtitle, src, sizeof(*subtitle));
-        if ( src->extradata )
+        if (src->extradata)
         {
-            subtitle->extradata = malloc( src->extradata_size );
-            memcpy( subtitle->extradata, src->extradata, src->extradata_size );
+            subtitle->extradata = hb_data_dup(src->extradata);
         }
         if (src->name != NULL)
         {
@@ -5401,7 +5457,7 @@ void hb_subtitle_close( hb_subtitle_t **_sub )
         free((char*)sub->name);
         free((char*)sub->config.name);
         free((char*)sub->config.src_filename);
-        free(sub->extradata);
+        hb_data_close(&sub->extradata);
         free(sub);
         *_sub = NULL;
     }
@@ -5412,58 +5468,6 @@ void hb_subtitle_close( hb_subtitle_t **_sub )
  **********************************************************************
  *
  *********************************************************************/
-int hb_subtitle_add_ssa_header(hb_subtitle_t *subtitle, const char *font,
-                               int fs, int w, int h)
-{
-    // Free any pre-existing extradata
-    free(subtitle->extradata);
-
-    float shadow_size = fs / 36.0;
-    float outline_size = fs / 30.0;
-
-    char *shadow_size_string = hb_strdup_printf("%.2f", shadow_size);
-    hb_str_from_locale(shadow_size_string);
-
-    char *outline_size_string = hb_strdup_printf("%.2f", outline_size);
-    hb_str_from_locale(outline_size_string);
-
-    if (shadow_size_string == NULL || outline_size_string == NULL)
-    {
-        hb_error("hb_subtitle_add_ssa_header: malloc failed");
-        return 0;
-    }
-
-    // SRT subtitles are represented internally as SSA
-    // Create an SSA header
-    const char * ssa_header =
-        "[Script Info]\r\n"
-        "ScriptType: v4.00+\r\n"
-        "Collisions: Normal\r\n"
-        "PlayResX: %d\r\n"
-        "PlayResY: %d\r\n"
-        "Timer: 100.0\r\n"
-        "WrapStyle: 0\r\n"
-        "ScaledBorderAndShadow: yes\r\n"
-        "\r\n"
-        "[V4+ Styles]\r\n"
-        "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\r\n"
-        "Style: Default,%s,%d,&H00FFFFFF,&H00FFFFFF,&H000F0F0F,&H000F0F0F,0,0,0,0,100,100,0,0.00,1,%s,%s,2,20,20,20,0\r\n";
-
-    subtitle->extradata = (uint8_t *)hb_strdup_printf(ssa_header, w, h, font, fs, outline_size_string, shadow_size_string);
-
-    free(shadow_size_string);
-    free(outline_size_string);
-
-    if (subtitle->extradata == NULL)
-    {
-        hb_error("hb_subtitle_add_ssa_header: malloc failed");
-        return 0;
-    }
-    subtitle->extradata_size = strlen((char*)subtitle->extradata) + 1;
-
-    return 1;
-}
-
 int hb_subtitle_add(const hb_job_t * job, const hb_subtitle_config_t * subtitlecfg, int track)
 {
     hb_title_t *title = job->title;
diff --git a/libhb/decavcodec.c b/libhb/decavcodec.c
index f818d5fb1..c25ef1fce 100644
--- a/libhb/decavcodec.c
+++ b/libhb/decavcodec.c
@@ -50,6 +50,7 @@
 #include "handbrake/hwaccel.h"
 #include "handbrake/lang.h"
 #include "handbrake/audio_resample.h"
+#include "handbrake/extradata.h"
 
 #if HB_PROJECT_FEATURE_QSV
 #include "libavutil/hwcontext_qsv.h"
@@ -822,7 +823,8 @@ static int parse_adts_extradata( hb_audio_t * audio, AVCodecContext * context,
         return ret;
     }
 
-    if (audio->priv.config.extradata.length == 0)
+    if (audio->priv.extradata == NULL ||
+        (audio->priv.extradata && audio->priv.extradata->size == 0))
     {
         const uint8_t * extradata;
         size_t          size;
@@ -831,10 +833,7 @@ static int parse_adts_extradata( hb_audio_t * audio, AVCodecContext * context,
                                             &size);
         if (extradata != NULL && size > 0)
         {
-            int len;
-            len = MIN(size, HB_CONFIG_MAX_SIZE);
-            memcpy(audio->priv.config.extradata.bytes, extradata, len);
-            audio->priv.config.extradata.length = len;
+            hb_set_extradata(&audio->priv.extradata, extradata, size);
         }
     }
 
diff --git a/libhb/decavsub.c b/libhb/decavsub.c
index f151b7e0a..0763d4a87 100644
--- a/libhb/decavsub.c
+++ b/libhb/decavsub.c
@@ -10,6 +10,7 @@
 #include "handbrake/handbrake.h"
 #include "handbrake/hbffmpeg.h"
 #include "handbrake/decavsub.h"
+#include "handbrake/extradata.h"
 
 struct hb_avsub_context_s
 {
@@ -123,14 +124,14 @@ hb_avsub_context_t * decavsubInit( hb_work_object_t * w, hb_job_t * job )
             case AV_CODEC_ID_EIA_608:
             {
                 // Mono font for CC
-                hb_subtitle_add_ssa_header(ctx->subtitle, HB_FONT_MONO,
-                    20, 384, 288);
+                hb_set_ssa_extradata(&ctx->subtitle->extradata,
+                                     HB_FONT_MONO, 20, 384, 288);
             } break;
 
             default:
             {
-                hb_subtitle_add_ssa_header(ctx->subtitle, HB_FONT_SANS,
-                    .066 * job->title->geometry.height, width, height);
+                hb_set_ssa_extradata(&ctx->subtitle->extradata, HB_FONT_SANS,
+                                     .066 * job->title->geometry.height, width, height);
             } break;
         }
     }
diff --git a/libhb/decsrtsub.c b/libhb/decsrtsub.c
index 17b714b0a..3af20868d 100644
--- a/libhb/decsrtsub.c
+++ b/libhb/decsrtsub.c
@@ -16,6 +16,7 @@
 #include "handbrake/handbrake.h"
 #include "handbrake/colormap.h"
 #include "handbrake/decavsub.h"
+#include "handbrake/extradata.h"
 
 struct start_and_end {
     unsigned long start, end;
@@ -566,9 +567,9 @@ static int decsrtInit( hb_work_object_t * w, hb_job_t * job )
     // Generate generic SSA Script Info.
     int height = job->title->geometry.height - job->crop[0] - job->crop[1];
     int width = job->title->geometry.width - job->crop[2] - job->crop[3];
-    hb_subtitle_add_ssa_header(w->subtitle, HB_FONT_SANS,
-                               .066 * job->title->geometry.height,
-                               width, height);
+    hb_set_ssa_extradata(&w->subtitle->extradata, HB_FONT_SANS,
+                         .066 * job->title->geometry.height,
+                         width, height);
     return 0;
 
 fail:
diff --git a/libhb/decssasub.c b/libhb/decssasub.c
index 32a43b9bc..73110c58f 100644
--- a/libhb/decssasub.c
+++ b/libhb/decssasub.c
@@ -26,6 +26,7 @@
 
 #include "handbrake/handbrake.h"
 #include "handbrake/decavsub.h"
+#include "handbrake/extradata.h"
 #include "libavformat/avformat.h"
 
 struct hb_work_private_s
@@ -57,11 +58,7 @@ static int extradataInit( hb_work_private_t * pv )
     }
     if (st->codecpar->extradata != NULL)
     {
-        pv->subtitle->extradata = malloc(st->codecpar->extradata_size + 1);
-        memcpy(pv->subtitle->extradata,
-               st->codecpar->extradata, st->codecpar->extradata_size);
-        pv->subtitle->extradata[st->codecpar->extradata_size] = 0;
-        pv->subtitle->extradata_size = st->codecpar->extradata_size + 1;
+        hb_set_text_extradata(&pv->subtitle->extradata, st->codecpar->extradata, st->codecpar->extradata_size);
     }
     return 0;
 }
diff --git a/libhb/dectx3gsub.c b/libhb/dectx3gsub.c
index 0803a1bc9..1f7348279 100644
--- a/libhb/dectx3gsub.c
+++ b/libhb/dectx3gsub.c
@@ -21,6 +21,7 @@
 #include <stdio.h>
 #include "handbrake/handbrake.h"
 #include "handbrake/colormap.h"
+#include "handbrake/extradata.h"
 
 struct hb_work_private_s
 {
@@ -260,9 +261,9 @@ static int dectx3gInit( hb_work_object_t * w, hb_job_t * job )
     // For now we just create a generic SSA Script Info.
     int height = job->title->geometry.height - job->crop[0] - job->crop[1];
     int width = job->title->geometry.width - job->crop[2] - job->crop[3];
-    hb_subtitle_add_ssa_header(w->subtitle, HB_FONT_SANS,
-                               .066 * job->title->geometry.height,
-                               width, height);
+    hb_set_ssa_extradata(&w->subtitle->extradata, HB_FONT_SANS,
+                         .066 * job->title->geometry.height,
+                         width, height);
 
     return 0;
 }
diff --git a/libhb/enc_qsv.c b/libhb/enc_qsv.c
index c7cbbb1b7..4ba5c2ebe 100644
--- a/libhb/enc_qsv.c
+++ b/libhb/enc_qsv.c
@@ -38,6 +38,7 @@ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "handbrake/qsv_memory.h"
 #include "handbrake/h264_common.h"
 #include "handbrake/h265_common.h"
+#include "handbrake/extradata.h"
 
 #include "libavutil/hwcontext_qsv.h"
 #include "libavutil/hwcontext.h"
@@ -648,7 +649,9 @@ static int qsv_hevc_make_header(hb_work_object_t *w, mfxSession session, const m
     len = bitstream.DataLength;
     buf = bitstream.Data + bitstream.DataOffset;
     end = bitstream.Data + bitstream.DataOffset + bitstream.DataLength;
-    w->config->h265.headers_length = 0;
+
+    size_t extradata_size = 0;
+    uint8_t extradata[HB_CONFIG_MAX_SIZE];
 
     while ((buf = hb_annexb_find_next_nalu(buf, &len)) != NULL)
     {
@@ -665,19 +668,20 @@ static int qsv_hevc_make_header(hb_work_object_t *w, mfxSession session, const m
                 continue;
         }
 
-        size_t size = hb_nal_unit_write_annexb(NULL, buf, len) + w->config->h265.headers_length;
-        if (sizeof(w->config->h265.headers) < size)
+        size_t size = hb_nal_unit_write_annexb(NULL, buf, len) + extradata_size;
+        if (sizeof(extradata) < size)
         {
             /* Will never happen in practice */
             hb_log("qsv_hevc_make_header: header too large (size: %lu, max: %lu)",
-                   size, sizeof(w->config->h265.headers));
+                   size, sizeof(extradata));
         }
 
-        w->config->h265.headers_length += hb_nal_unit_write_annexb(w->config->h265.headers +
-                                                                   w->config->h265.headers_length, buf, len);
+        extradata_size += hb_nal_unit_write_annexb(extradata + extradata_size, buf, len);
         len = end - buf;
     }
 
+    hb_set_extradata(w->extradata, extradata, extradata_size);
+
 end:
     if (bitstream.Data)
         av_free(bitstream.Data);
@@ -1714,16 +1718,20 @@ int encqsvInit(hb_work_object_t *w, hb_job_t *job)
     memset(&videoParam, 0, sizeof(mfxVideoParam));
     videoParam.ExtParam = extParamArray;
     videoParam.NumExtParam = 0;
+
+    uint8_t sps[HB_CONFIG_MAX_SIZE];
+    uint8_t pps[HB_CONFIG_MAX_SIZE];
+
     // introduced in API 1.3
     memset(sps_pps, 0, sizeof(mfxExtCodingOptionSPSPPS));
     sps_pps->Header.BufferId = MFX_EXTBUFF_CODING_OPTION_SPSPPS;
     sps_pps->Header.BufferSz = sizeof(mfxExtCodingOptionSPSPPS);
     sps_pps->SPSId           = 0;
-    sps_pps->SPSBuffer       = w->config->h264.sps;
-    sps_pps->SPSBufSize      = sizeof(w->config->h264.sps);
+    sps_pps->SPSBuffer       = sps;
+    sps_pps->SPSBufSize      = sizeof(sps);
     sps_pps->PPSId           = 0;
-    sps_pps->PPSBuffer       = w->config->h264.pps;
-    sps_pps->PPSBufSize      = sizeof(w->config->h264.pps);
+    sps_pps->PPSBuffer       = pps;
+    sps_pps->PPSBufSize      = sizeof(pps);
     if (pv->param.videoParam->mfx.CodecId == MFX_CODEC_AVC)
     {
         videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)sps_pps;
@@ -1793,12 +1801,9 @@ int encqsvInit(hb_work_object_t *w, hb_job_t *job)
     if (videoParam.mfx.CodecId == MFX_CODEC_AVC)
     {
         // remove 4-byte Annex B NAL unit prefix (0x00 0x00 0x00 0x01)
-        w->config->h264.sps_length = sps_pps->SPSBufSize - 4;
-        memmove(w->config->h264.sps, w->config->h264.sps + 4,
-                w->config->h264.sps_length);
-        w->config->h264.pps_length = sps_pps->PPSBufSize - 4;
-        memmove(w->config->h264.pps, w->config->h264.pps + 4,
-                w->config->h264.pps_length);
+        hb_set_h264_extradata(w->extradata,
+                              sps + 4, sps_pps->SPSBufSize - 4,
+                              pps + 4, sps_pps->PPSBufSize - 4);
     }
     else if (videoParam.mfx.CodecId == MFX_CODEC_HEVC)
     {
@@ -1832,7 +1837,7 @@ int encqsvInit(hb_work_object_t *w, hb_job_t *job)
         {
             case MFX_CODEC_AVC:
             case MFX_CODEC_HEVC:
-                pv->init_delay = &w->config->init_delay;
+                pv->init_delay = &w->init_delay;
                 break;
             default:
                 break;
diff --git a/libhb/encavcodec.c b/libhb/encavcodec.c
index de118d404..89b56eacd 100644
--- a/libhb/encavcodec.c
+++ b/libhb/encavcodec.c
@@ -17,6 +17,7 @@
 #include "handbrake/av1_common.h"
 #include "handbrake/nal_units.h"
 #include "handbrake/nvenc_common.h"
+#include "handbrake/extradata.h"
 
 /*
  * The frame info struct remembers information about each frame across calls
@@ -852,9 +853,7 @@ int encavcodecInit( hb_work_object_t * w, hb_job_t * job )
 
     if (context->extradata != NULL)
     {
-        memcpy(w->config->extradata.bytes, context->extradata,
-                                           context->extradata_size);
-        w->config->extradata.length = context->extradata_size;
+        hb_set_extradata(w->extradata, context->extradata, context->extradata_size);
     }
 
 done:
@@ -923,7 +922,7 @@ static void compute_dts_offset( hb_work_private_t * pv, hb_buffer_t * buf )
         if ( ( pv->frameno_in ) == pv->job->areBframes )
         {
             pv->dts_delay = buf->s.start;
-            pv->job->config.init_delay = pv->dts_delay;
+            pv->job->init_delay = pv->dts_delay;
         }
     }
 }
diff --git a/libhb/encavcodecaudio.c b/libhb/encavcodecaudio.c
index 08667c36b..bdfbc7ccb 100644
--- a/libhb/encavcodecaudio.c
+++ b/libhb/encavcodecaudio.c
@@ -9,6 +9,7 @@
 
 #include "handbrake/handbrake.h"
 #include "handbrake/hbffmpeg.h"
+#include "handbrake/extradata.h"
 
 struct hb_work_private_s
 {
@@ -222,8 +223,7 @@ static int encavcodecaInit(hb_work_object_t *w, hb_job_t *job)
         hb_error("encavcodecaInit: hb_avcodec_open() failed");
         return 1;
     }
-    w->config->init_delay = av_rescale(context->initial_padding,
-                                       90000, context->sample_rate);
+    *w->init_delay = av_rescale(context->initial_padding, 90000, context->sample_rate);
 
     // avcodec_open populates the opts dictionary with the
     // things it didn't recognize.
@@ -289,9 +289,7 @@ static int encavcodecaInit(hb_work_object_t *w, hb_job_t *job)
 
     if (context->extradata != NULL)
     {
-        memcpy(w->config->extradata.bytes, context->extradata,
-               context->extradata_size);
-        w->config->extradata.length = context->extradata_size;
+        hb_set_extradata(w->extradata, context->extradata, context->extradata_size);
     }
 
     return 0;
@@ -311,9 +309,8 @@ static void Finalize(hb_work_object_t *w)
     // Then we need to recopy the header since it was modified
     if (pv->context->extradata != NULL)
     {
-        memcpy(w->config->extradata.bytes, pv->context->extradata,
-               pv->context->extradata_size);
-        w->config->extradata.length = pv->context->extradata_size;
+        hb_set_extradata(w->extradata, pv->context->extradata,
+                         pv->context->extradata_size);
     }
 }
 
diff --git a/libhb/enctheora.c b/libhb/enctheora.c
index 9b572ce6d..8d829b4ae 100644
--- a/libhb/enctheora.c
+++ b/libhb/enctheora.c
@@ -8,6 +8,7 @@
  */
 
 #include "handbrake/handbrake.h"
+#include "handbrake/extradata.h"
 #include "theora/codec.h"
 #include "theora/theoraenc.h"
 
@@ -169,18 +170,19 @@ int enctheoraInit( hb_work_object_t * w, hb_job_t * job )
 
     th_comment_init( &tc );
 
-    ogg_packet *header;
+    uint8_t headers[3][HB_CONFIG_MAX_SIZE];
 
-    int ii;
-    for (ii = 0; ii < 3; ii++)
+    for (int ii = 0; ii < 3; ii++)
     {
-        th_encode_flushheader( pv->ctx, &tc, &op );
-        header = (ogg_packet*)w->config->theora.headers[ii];
+        th_encode_flushheader(pv->ctx, &tc, &op);
+        ogg_packet *header = (ogg_packet *)headers[ii];
         memcpy(header, &op, sizeof(op));
-        header->packet = w->config->theora.headers[ii] + sizeof(ogg_packet);
-        memcpy(header->packet, op.packet, op.bytes );
+        header->packet = headers[ii] + sizeof(ogg_packet);
+        memcpy(header->packet, op.packet, op.bytes);
     }
 
+    hb_set_xiph_extradata(w->extradata, headers);
+
     th_comment_clear( &tc );
 
     return 0;
diff --git a/libhb/encvorbis.c b/libhb/encvorbis.c
index 18f2b8642..f6c2bd9d1 100644
--- a/libhb/encvorbis.c
+++ b/libhb/encvorbis.c
@@ -8,7 +8,7 @@
  */
 
 #include "handbrake/hbffmpeg.h"
-
+#include "handbrake/extradata.h"
 #include "handbrake/handbrake.h"
 #include "handbrake/audio_remap.h"
 
@@ -60,18 +60,8 @@ int encvorbisInit(hb_work_object_t *w, hb_job_t *job)
     w->private_data = pv;
     pv->job = job;
 
-    int i;
-    ogg_packet header[3];
-
     hb_log("encvorbis: opening libvorbis");
 
-    /* init */
-    for (i = 0; i < 3; i++)
-    {
-        // Zero vorbis headers so that we don't crash in mk_laceXiph
-        // when vorbis_encode_setup_managed fails.
-        memset(w->config->vorbis.headers[i], 0, sizeof(ogg_packet));
-    }
     vorbis_info_init(&pv->vi);
 
     pv->out_discrete_channels =
@@ -109,24 +99,28 @@ int encvorbisInit(hb_work_object_t *w, hb_job_t *job)
     /* add a comment */
     vorbis_comment_init(&pv->vc);
     vorbis_comment_add_tag(&pv->vc, "Encoder", "HandBrake");
-    vorbis_comment_add_tag(&pv->vc, "LANGUAGE", w->config->vorbis.language);
+    vorbis_comment_add_tag(&pv->vc, "LANGUAGE", audio->config.lang.simple);
 
     /* set up the analysis state and auxiliary encoding storage */
     vorbis_analysis_init(&pv->vd, &pv->vi);
     vorbis_block_init(&pv->vd, &pv->vb);
 
     /* get the 3 headers */
+    ogg_packet header[3];
     vorbis_analysis_headerout(&pv->vd, &pv->vc,
                               &header[0], &header[1], &header[2]);
-    ogg_packet *pheader;
-    for (i = 0; i < 3; i++)
+
+    uint8_t headers[3][HB_CONFIG_MAX_SIZE];
+    for (int i = 0; i < 3; i++)
     {
-        pheader = (ogg_packet*)w->config->vorbis.headers[i];
+        ogg_packet *pheader = (ogg_packet *)headers[i];
         memcpy(pheader, &header[i], sizeof(ogg_packet));
-        pheader->packet = w->config->vorbis.headers[i] + sizeof(ogg_packet);
+        pheader->packet = headers[i] + sizeof(ogg_packet);
         memcpy(pheader->packet, header[i].packet, header[i].bytes );
     }
 
+    hb_set_xiph_extradata(w->extradata, headers);
+
     pv->input_samples = pv->out_discrete_channels * OGGVORBIS_FRAME_SIZE;
     audio->config.out.samples_per_frame = OGGVORBIS_FRAME_SIZE;
     pv->buf = malloc(pv->input_samples * sizeof(float));
diff --git a/libhb/encx264.c b/libhb/encx264.c
index b28181673..8b401226a 100644
--- a/libhb/encx264.c
+++ b/libhb/encx264.c
@@ -12,6 +12,7 @@
 #include "handbrake/handbrake.h"
 #include "handbrake/hb_dict.h"
 #include "handbrake/encx264.h"
+#include "handbrake/extradata.h"
 
 int  encx264Init( hb_work_object_t *, hb_job_t * );
 int  encx264Work( hb_work_object_t *, hb_buffer_t **, hb_buffer_t ** );
@@ -649,13 +650,15 @@ int encx264Init( hb_work_object_t * w, hb_job_t * job )
 
     pv->api->encoder_headers( pv->x264, &nal, &nal_count );
 
-    /* Sequence Parameter Set */
-    memcpy(w->config->h264.sps, nal[0].p_payload + 4, nal[0].i_payload - 4);
-    w->config->h264.sps_length = nal[0].i_payload - 4;
-
-    /* Picture Parameter Set */
-    memcpy(w->config->h264.pps, nal[1].p_payload + 4, nal[1].i_payload - 4);
-    w->config->h264.pps_length = nal[1].i_payload - 4;
+    if (hb_set_h264_extradata(w->extradata,
+                              nal[0].p_payload + 4, nal[0].i_payload - 4,
+                              nal[1].p_payload + 4, nal[1].i_payload - 4))
+    {
+        hb_error("encx264: set extradata failed.");
+        free( pv );
+        w->private_data = NULL;
+        return 1;
+    }
 
     pv->api->picture_init( &pv->pic_in );
 
@@ -709,9 +712,9 @@ static hb_buffer_t *nal_encode( hb_work_object_t *w, x264_picture_t *pic_out,
     buf->s.start        = pic_out->i_pts;
     buf->s.stop         = AV_NOPTS_VALUE;
     buf->s.renderOffset = pic_out->i_dts;
-    if ( !w->config->init_delay && pic_out->i_dts < 0 )
+    if (!*w->init_delay && pic_out->i_dts < 0)
     {
-        w->config->init_delay = -pic_out->i_dts;
+        *w->init_delay = -pic_out->i_dts;
     }
 
     /* Determine what type of frame we have. */
diff --git a/libhb/encx265.c b/libhb/encx265.c
index 8943c4c0c..f163b33c2 100644
--- a/libhb/encx265.c
+++ b/libhb/encx265.c
@@ -17,6 +17,8 @@
 #include "handbrake/h265_common.h"
 #include "handbrake/dovi_common.h"
 #include "handbrake/hdr10plus.h"
+#include "handbrake/extradata.h"
+
 #include "x265.h"
 
 int  encx265Init (hb_work_object_t*, hb_job_t*);
@@ -543,13 +545,11 @@ int encx265Init(hb_work_object_t *w, hb_job_t *job)
         hb_error("encx265: x265_encoder_headers failed (%d)", ret);
         goto fail;
     }
-    if (ret > sizeof(w->config->h265.headers))
+    if (hb_set_extradata(w->extradata, nal->payload, ret))
     {
         hb_error("encx265: bitstream headers too large (%d)", ret);
         goto fail;
     }
-    memcpy(w->config->h265.headers, nal->payload, ret);
-    w->config->h265.headers_length = ret;
 
     return 0;
 
@@ -641,9 +641,9 @@ static hb_buffer_t* nal_encode(hb_work_object_t *w,
     buf->s.stop         = pic_out->pts + buf->s.duration;
     buf->s.start        = pic_out->pts;
     buf->s.renderOffset = pic_out->dts;
-    if (w->config->init_delay == 0 && pic_out->dts < 0)
+    if (*w->init_delay == 0 && pic_out->dts < 0)
     {
-        w->config->init_delay -= pic_out->dts;
+        *w->init_delay -= pic_out->dts;
     }
 
     switch (pic_out->sliceType)
diff --git a/libhb/handbrake/common.h b/libhb/handbrake/common.h
index 6de81b6e0..d1d047a4a 100644
--- a/libhb/handbrake/common.h
+++ b/libhb/handbrake/common.h
@@ -159,8 +159,6 @@ void hb_audio_config_init(hb_audio_config_t * audiocfg);
 int hb_audio_add(const hb_job_t * job, const hb_audio_config_t * audiocfg);
 hb_audio_config_t * hb_list_audio_config_item(hb_list_t * list, int i);
 
-int hb_subtitle_add_ssa_header(hb_subtitle_t *subtitle, const char *font,
-                               int fs, int width, int height);
 hb_subtitle_t *hb_subtitle_copy(const hb_subtitle_t *src);
 hb_list_t *hb_subtitle_list_copy(const hb_list_t *src);
 void hb_subtitle_close( hb_subtitle_t **sub );
@@ -835,6 +833,9 @@ struct hb_job_s
 
     uint64_t        st_paused;
 
+    int             init_delay;
+    hb_data_t     * extradata;
+
     hb_fifo_t     * fifo_mpeg2;   /* MPEG-2 video ES */
     hb_fifo_t     * fifo_raw;     /* Raw pictures */
     hb_fifo_t     * fifo_sync;    /* Raw pictures, framerate corrected */
@@ -843,8 +844,6 @@ struct hb_job_s
 
     hb_list_t     * list_work;
 
-    hb_esconfig_t config;
-
     hb_mux_data_t * mux_data;
 
     int64_t         reader_pts_offset; // Reader can discard some video.
@@ -994,13 +993,16 @@ struct hb_audio_s
 
     hb_audio_config_t config;
 
-    struct {
+    struct
+    {
+        int           init_delay;
+        hb_data_t   * extradata;
+
         hb_fifo_t * fifo_in;   /* AC3/MPEG/LPCM ES */
         hb_fifo_t * fifo_raw;  /* Raw audio */
         hb_fifo_t * fifo_sync; /* Resampled, synced raw audio */
         hb_fifo_t * fifo_out;  /* MP3/AAC/Vorbis ES */
 
-        hb_esconfig_t config;
         hb_mux_data_t * mux_data;
         hb_fifo_t     * scan_cache;
     } priv;
@@ -1105,10 +1107,6 @@ struct hb_subtitle_s
     int         width;
     int         height;
 
-    // Codec private data for subtitles originating from FFMPEG sources
-    uint8_t *   extradata;
-    int         extradata_size;
-
     int hits;     /* How many hits/occurrences of this subtitle */
     int forced_hits; /* How many forced hits in this subtitle */
 
@@ -1121,6 +1119,9 @@ struct hb_subtitle_s
     uint32_t        substream_type; /* substream for multiplexed streams */
     hb_rational_t   timebase;
 
+    // Codec private data for subtitles originating from FFMPEG sources
+    hb_data_t   * extradata;
+
     hb_fifo_t     * fifo_in;        /* SPU ES */
     hb_fifo_t     * fifo_raw;       /* Decoded SPU */
     hb_fifo_t     * fifo_out;       /* Correct Timestamps, ready to be muxed */
@@ -1355,7 +1356,9 @@ struct hb_work_object_s
 
     hb_fifo_t         * fifo_in;
     hb_fifo_t         * fifo_out;
-    hb_esconfig_t     * config;
+
+    int               * init_delay;
+    hb_data_t        ** extradata;
 
     /* Pointer hb_audio_t so we have access to the info in the audio worker threads. */
     hb_audio_t        * audio;
diff --git a/libhb/handbrake/hbtypes.h b/libhb/handbrake/hbtypes.h
index 487097df2..c1e2bc22b 100644
--- a/libhb/handbrake/hbtypes.h
+++ b/libhb/handbrake/hbtypes.h
@@ -35,7 +35,7 @@ typedef struct hb_attachment_s hb_attachment_t;
 typedef struct hb_metadata_s hb_metadata_t;
 typedef struct hb_coverart_s hb_coverart_t;
 typedef struct hb_state_s hb_state_t;
-typedef struct hb_esconfig_s     hb_esconfig_t;
+typedef struct hb_data_s hb_data_t;
 typedef struct hb_work_private_s hb_work_private_t;
 typedef struct hb_work_object_s  hb_work_object_t;
 typedef struct hb_filter_private_s hb_filter_private_t;
diff --git a/libhb/handbrake/internal.h b/libhb/handbrake/internal.h
index 9b129328f..cf3db1e23 100644
--- a/libhb/handbrake/internal.h
+++ b/libhb/handbrake/internal.h
@@ -393,53 +393,19 @@ void hb_stream_set_need_keyframe( hb_stream_t *stream, int need_keyframe );
 /***********************************************************************
  * Work objects
  **********************************************************************/
-#define HB_CONFIG_MAX_SIZE (2*8192)
-struct hb_esconfig_s
-{
-    int init_delay;
-
-    union
-    {
-
-    struct
-    {
-        uint8_t bytes[HB_CONFIG_MAX_SIZE];
-        int     length;
-    } mpeg4;
-
-	struct
-	{
-	    uint8_t  sps[HB_CONFIG_MAX_SIZE];
-	    int       sps_length;
-	    uint8_t  pps[HB_CONFIG_MAX_SIZE];
-	    int       pps_length;
-	} h264;
-
-    struct
-    {
-        uint8_t headers[HB_CONFIG_MAX_SIZE];
-        int     headers_length;
-    } h265;
 
-    struct
-    {
-        uint8_t headers[3][HB_CONFIG_MAX_SIZE];
-    } theora;
-
-    struct
-    {
-        uint8_t bytes[HB_CONFIG_MAX_SIZE];
-        int     length;
-    } extradata;
+#define HB_CONFIG_MAX_SIZE (2*8192)
 
-    struct
-    {
-        uint8_t headers[3][HB_CONFIG_MAX_SIZE];
-        char *language;
-    } vorbis;
-    };
+struct hb_data_s
+{
+    uint8_t *bytes;
+    size_t   size;
 };
 
+hb_data_t * hb_data_init(size_t size);
+void        hb_data_close(hb_data_t **);
+hb_data_t * hb_data_dup(const hb_data_t *src);
+
 enum
 {
     WORK_NONE = 0,
diff --git a/libhb/muxavformat.c b/libhb/muxavformat.c
index 20ecda035..255e3d1f1 100644
--- a/libhb/muxavformat.c
+++ b/libhb/muxavformat.c
@@ -8,11 +8,9 @@
  */
 
 #include <time.h>
-#include <ogg/ogg.h>
 #include "libavcodec/bsf.h"
 #include "libavformat/avformat.h"
 #include "libavutil/avstring.h"
-#include "libavutil/intreadwrite.h"
 
 #include "handbrake/handbrake.h"
 #include "handbrake/ssautil.h"
@@ -136,6 +134,32 @@ static char* lookup_lang_code(int mux, char *iso639_2)
     return out;
 }
 
+static int set_extradata(hb_data_t *extradata, uint8_t **priv_data, int *priv_size)
+{
+    if (*priv_data)
+    {
+        av_freep(priv_data);
+        *priv_size = 0;
+    }
+
+    if (extradata && extradata->size > 0)
+    {
+        // libavformat can over-read the buffer by up to 8 bytes
+        // when it fills it's get_bits cache.
+        //
+        // So allocate extra bytes
+        *priv_size = extradata->size;
+        *priv_data = av_malloc(extradata->size + AV_INPUT_BUFFER_PADDING_SIZE);
+        if (priv_data == NULL)
+        {
+            hb_error("extradata: malloc failure");
+            return 1;
+        }
+        memcpy(*priv_data, extradata->bytes, extradata->size);
+    }
+    return 0;
+}
+
 /**********************************************************************
  * avformatInit
  **********************************************************************
@@ -257,57 +281,12 @@ static int avformatInit( hb_mux_object_t * m )
     track->st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
     track->st->time_base            = m->time_base;
 
-    uint8_t *priv_data = NULL;
-    int priv_size = 0;
     switch (job->vcodec)
     {
         case HB_VCODEC_X264_8BIT:
         case HB_VCODEC_X264_10BIT:
         case HB_VCODEC_QSV_H264:
         case HB_VCODEC_VT_H264:
-            track->st->codecpar->codec_id = AV_CODEC_ID_H264;
-            if (job->mux == HB_MUX_AV_MP4 && job->inline_parameter_sets)
-            {
-                track->st->codecpar->codec_tag = MKTAG('a','v','c','3');
-            }
-            else
-            {
-                track->st->codecpar->codec_tag = MKTAG('a','v','c','1');
-            }
-
-            /* Taken from x264 muxers.c */
-            priv_size = 5 + 1 + 2 + job->config.h264.sps_length + 1 + 2 +
-                        job->config.h264.pps_length;
-            priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-            if (priv_data == NULL)
-            {
-                hb_error("H.264 extradata: malloc failure");
-                goto error;
-            }
-
-            priv_data[0] = 1;
-            priv_data[1] = job->config.h264.sps[1]; /* AVCProfileIndication */
-            priv_data[2] = job->config.h264.sps[2]; /* profile_compat */
-            priv_data[3] = job->config.h264.sps[3]; /* AVCLevelIndication */
-            priv_data[4] = 0xff; // nalu size length is four bytes
-            priv_data[5] = 0xe1; // one sps
-
-            priv_data[6] = job->config.h264.sps_length >> 8;
-            priv_data[7] = job->config.h264.sps_length;
-
-            memcpy(priv_data+8, job->config.h264.sps,
-                   job->config.h264.sps_length);
-
-            priv_data[8+job->config.h264.sps_length] = 1; // one pps
-            priv_data[9+job->config.h264.sps_length] =
-                                        job->config.h264.pps_length >> 8;
-            priv_data[10+job->config.h264.sps_length] =
-                                        job->config.h264.pps_length;
-
-            memcpy(priv_data+11+job->config.h264.sps_length,
-                   job->config.h264.pps, job->config.h264.pps_length );
-            break;
-
         case HB_VCODEC_FFMPEG_VCE_H264:
         case HB_VCODEC_FFMPEG_NVENC_H264:
         case HB_VCODEC_FFMPEG_MF_H264:
@@ -320,68 +299,23 @@ static int avformatInit( hb_mux_object_t * m )
             {
                 track->st->codecpar->codec_tag = MKTAG('a','v','c','1');
             }
-            if (job->config.extradata.length > 0)
-            {
-                priv_size = job->config.extradata.length;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                if (priv_data == NULL)
-                {
-                    hb_error("H.264 extradata: malloc failure");
-                    goto error;
-                }
-                memcpy(priv_data,
-                       job->config.extradata.bytes,
-                       job->config.extradata.length);
-            }
             break;
 
         case HB_VCODEC_FFMPEG_MPEG4:
             track->st->codecpar->codec_id = AV_CODEC_ID_MPEG4;
-
-            if (job->config.extradata.length > 0)
-            {
-                priv_size = job->config.extradata.length;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                if (priv_data == NULL)
-                {
-                    hb_error("MPEG-4 extradata: malloc failure");
-                    goto error;
-                }
-                memcpy(priv_data,
-                       job->config.extradata.bytes,
-                       job->config.extradata.length);
-            }
             break;
 
         case HB_VCODEC_FFMPEG_MPEG2:
             track->st->codecpar->codec_id = AV_CODEC_ID_MPEG2VIDEO;
-
-            if (job->config.extradata.length > 0)
-            {
-                priv_size = job->config.extradata.length;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                if (priv_data == NULL)
-                {
-                    hb_error("MPEG-2 extradata: malloc failure");
-                    goto error;
-                }
-                memcpy(priv_data,
-                       job->config.extradata.bytes,
-                       job->config.extradata.length);
-            }
             break;
 
         case HB_VCODEC_FFMPEG_VP8:
             track->st->codecpar->codec_id = AV_CODEC_ID_VP8;
-            priv_data                  = NULL;
-            priv_size                  = 0;
             break;
 
         case HB_VCODEC_FFMPEG_VP9:
         case HB_VCODEC_FFMPEG_VP9_10BIT:
             track->st->codecpar->codec_id = AV_CODEC_ID_VP9;
-            priv_data                  = NULL;
-            priv_size                  = 0;
             break;
 
         case HB_VCODEC_SVT_AV1:
@@ -390,20 +324,6 @@ static int avformatInit( hb_mux_object_t * m )
         case HB_VCODEC_FFMPEG_NVENC_AV1_10BIT:
         case HB_VCODEC_FFMPEG_VCE_AV1:
             track->st->codecpar->codec_id = AV_CODEC_ID_AV1;
-
-            if (job->config.extradata.length > 0)
-            {
-                priv_size = job->config.extradata.length;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                if (priv_data == NULL)
-                {
-                    hb_error("AV1 extradata: malloc failure");
-                    goto error;
-                }
-                memcpy(priv_data,
-                       job->config.extradata.bytes,
-                       job->config.extradata.length);
-            }
             break;
 
         case HB_VCODEC_QSV_AV1_10BIT:
@@ -414,8 +334,6 @@ static int avformatInit( hb_mux_object_t * m )
             int                       ret;
 
             track->st->codecpar->codec_id = AV_CODEC_ID_AV1;
-            priv_data                  = NULL;
-            priv_size                  = 0;
 
             bsf = av_bsf_get_by_name("extract_extradata");
             ret = av_bsf_alloc(bsf, &ctx);
@@ -426,8 +344,6 @@ static int avformatInit( hb_mux_object_t * m )
             }
 
             track->bitstream_context = ctx;
-            track->st->codecpar->extradata = priv_data;
-            track->st->codecpar->extradata_size = priv_size;
             if (track->bitstream_context != NULL)
             {
                 avcodec_parameters_copy(track->bitstream_context->par_in,
@@ -441,36 +357,8 @@ static int avformatInit( hb_mux_object_t * m )
             }
         } break;
         case HB_VCODEC_THEORA:
-        {
             track->st->codecpar->codec_id = AV_CODEC_ID_THEORA;
-
-            int size = 0;
-            ogg_packet *ogg_headers[3];
-
-            for (ii = 0; ii < 3; ii++)
-            {
-                ogg_headers[ii] = (ogg_packet *)job->config.theora.headers[ii];
-                size += ogg_headers[ii]->bytes + 2;
-            }
-
-            priv_size = size;
-            priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-            if (priv_data == NULL)
-            {
-                hb_error("Theora extradata: malloc failure");
-                goto error;
-            }
-
-            size = 0;
-            for(ii = 0; ii < 3; ii++)
-            {
-                AV_WB16(priv_data + size, ogg_headers[ii]->bytes);
-                size += 2;
-                memcpy(priv_data+size, ogg_headers[ii]->packet,
-                                       ogg_headers[ii]->bytes);
-                size += ogg_headers[ii]->bytes;
-            }
-        } break;
+            break;
 
         case HB_VCODEC_X265_8BIT:
         case HB_VCODEC_X265_10BIT:
@@ -480,29 +368,6 @@ static int avformatInit( hb_mux_object_t * m )
         case HB_VCODEC_QSV_H265_10BIT:
         case HB_VCODEC_VT_H265:
         case HB_VCODEC_VT_H265_10BIT:
-            track->st->codecpar->codec_id  = AV_CODEC_ID_HEVC;
-            if (job->mux == HB_MUX_AV_MP4 && job->inline_parameter_sets)
-            {
-                track->st->codecpar->codec_tag = MKTAG('h','e','v','1');
-            }
-            else
-            {
-                track->st->codecpar->codec_tag = MKTAG('h','v','c','1');
-            }
-
-            if (job->config.h265.headers_length > 0)
-            {
-                priv_size = job->config.h265.headers_length;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                if (priv_data == NULL)
-                {
-                    hb_error("H.265 extradata: malloc failure");
-                    goto error;
-                }
-                memcpy(priv_data, job->config.h265.headers, priv_size);
-            }
-            break;
-
         case HB_VCODEC_FFMPEG_VCE_H265:
         case HB_VCODEC_FFMPEG_VCE_H265_10BIT:
         case HB_VCODEC_FFMPEG_NVENC_H265:
@@ -517,27 +382,17 @@ static int avformatInit( hb_mux_object_t * m )
             {
                 track->st->codecpar->codec_tag = MKTAG('h','v','c','1');
             }
-            if (job->config.extradata.length > 0)
-            {
-                priv_size = job->config.extradata.length;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                if (priv_data == NULL)
-                {
-                    hb_error("H.265 extradata: malloc failure");
-                    goto error;
-                }
-                memcpy(priv_data,
-                       job->config.extradata.bytes,
-                       job->config.extradata.length);
-            }
             break;
 
         default:
             hb_error("muxavformat: Unknown video codec: %x", job->vcodec);
             goto error;
     }
-    track->st->codecpar->extradata = priv_data;
-    track->st->codecpar->extradata_size = priv_size;
+
+    if (set_extradata(job->extradata, &track->st->codecpar->extradata, &track->st->codecpar->extradata_size))
+    {
+        goto error;
+    }
 
     track->st->sample_aspect_ratio.num        = job->par.num;
     track->st->sample_aspect_ratio.den        = job->par.den;
@@ -545,6 +400,7 @@ static int avformatInit( hb_mux_object_t * m )
     track->st->codecpar->sample_aspect_ratio.den = job->par.den;
     track->st->codecpar->width                   = job->width;
     track->st->codecpar->height                  = job->height;
+    track->st->codecpar->format                  = job->output_pix_fmt;
     track->st->disposition |= AV_DISPOSITION_DEFAULT;
 
     track->st->codecpar->color_primaries = hb_output_color_prim(job);
@@ -664,7 +520,7 @@ static int avformatInit( hb_mux_object_t * m )
         }
 
         track->st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
-        track->st->codecpar->initial_padding = audio->priv.config.init_delay *
+        track->st->codecpar->initial_padding = audio->priv.init_delay *
                                         audio->config.out.samplerate / 90000;
         track->st->codecpar->frame_size = audio->config.out.samples_per_frame;
         if (job->mux == HB_MUX_AV_MP4)
@@ -677,8 +533,6 @@ static int avformatInit( hb_mux_object_t * m )
             track->st->time_base = m->time_base;
         }
 
-        priv_data = NULL;
-        priv_size = 0;
         switch (audio->config.out.codec & HB_ACODEC_MASK)
         {
             case HB_ACODEC_DCA:
@@ -702,70 +556,14 @@ static int avformatInit( hb_mux_object_t * m )
                 track->st->codecpar->codec_id = AV_CODEC_ID_MP3;
                 break;
             case HB_ACODEC_VORBIS:
-            {
                 track->st->codecpar->codec_id = AV_CODEC_ID_VORBIS;
-
-                int jj, size = 0;
-                ogg_packet *ogg_headers[3];
-
-                for (jj = 0; jj < 3; jj++)
-                {
-                    ogg_headers[jj] = (ogg_packet *)audio->priv.config.vorbis.headers[jj];
-                    size += ogg_headers[jj]->bytes + 2;
-                }
-
-                priv_size = size;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                if (priv_data == NULL)
-                {
-                    hb_error("Vorbis extradata: malloc failure");
-                    goto error;
-                }
-
-                size = 0;
-                for(jj = 0; jj < 3; jj++)
-                {
-                    AV_WB16(priv_data + size, ogg_headers[jj]->bytes);
-                    size += 2;
-                    memcpy(priv_data+size, ogg_headers[jj]->packet,
-                                           ogg_headers[jj]->bytes);
-                    size += ogg_headers[jj]->bytes;
-                }
-            } break;
+                break;
             case HB_ACODEC_OPUS:
                 track->st->codecpar->codec_id = AV_CODEC_ID_OPUS;
-
-                if (audio->priv.config.extradata.length)
-                {
-                    priv_size = audio->priv.config.extradata.length;
-                    priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                    if (priv_data == NULL)
-                    {
-                        hb_error("OPUS extradata: malloc failure");
-                        goto error;
-                    }
-                    memcpy(priv_data,
-                           audio->priv.config.extradata.bytes,
-                           audio->priv.config.extradata.length);
-                }
                 break;
             case HB_ACODEC_FFFLAC:
             case HB_ACODEC_FFFLAC24:
                 track->st->codecpar->codec_id = AV_CODEC_ID_FLAC;
-
-                if (audio->priv.config.extradata.length)
-                {
-                    priv_size = audio->priv.config.extradata.length;
-                    priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                    if (priv_data == NULL)
-                    {
-                        hb_error("FLAC extradata: malloc failure");
-                        goto error;
-                    }
-                    memcpy(priv_data,
-                           audio->priv.config.extradata.bytes,
-                           audio->priv.config.extradata.length);
-                }
                 break;
             case HB_ACODEC_FFAAC:
             case HB_ACODEC_CA_AAC:
@@ -774,24 +572,6 @@ static int avformatInit( hb_mux_object_t * m )
             case HB_ACODEC_FDK_HAAC:
                 track->st->codecpar->codec_id = AV_CODEC_ID_AAC;
 
-                // libav mkv muxer expects there to be extradata for
-                // AAC and will crash if it is NULL.
-                //
-                // Also, libav can over-read the buffer by up to 8 bytes
-                // when it fills it's get_bits cache.
-                //
-                // So allocate extra bytes
-                priv_size = audio->priv.config.extradata.length;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                if (priv_data == NULL)
-                {
-                    hb_error("AAC extradata: malloc failure");
-                    goto error;
-                }
-                memcpy(priv_data,
-                       audio->priv.config.extradata.bytes,
-                       audio->priv.config.extradata.length);
-
                 // AAC from pass-through source may be ADTS.
                 // Therefore inserting "aac_adtstoasc" bitstream filter is
                 // preferred.
@@ -819,8 +599,12 @@ static int avformatInit( hb_mux_object_t * m )
                          audio->config.out.codec);
                 goto error;
         }
-        track->st->codecpar->extradata = priv_data;
-        track->st->codecpar->extradata_size = priv_size;
+
+        if (set_extradata(audio->priv.extradata, &track->st->codecpar->extradata, &track->st->codecpar->extradata_size))
+        {
+            goto error;
+        }
+
         if (track->bitstream_context != NULL)
         {
             int ret;
@@ -1008,8 +792,8 @@ static int avformatInit( hb_mux_object_t * m )
         track->st->codecpar->width = subtitle->width;
         track->st->codecpar->height = subtitle->height;
 
-        priv_data = NULL;
-        priv_size = 0;
+        uint8_t *priv_data = NULL;
+        size_t   priv_size = 0;
         switch (subtitle->source)
         {
             case VOBSUB:
@@ -1045,11 +829,11 @@ static int avformatInit( hb_mux_object_t * m )
             case DVBSUB:
             {
                 track->st->codecpar->codec_id = AV_CODEC_ID_DVB_SUBTITLE;
-                if (subtitle->extradata != NULL)
+                if (subtitle->extradata != NULL && subtitle->extradata->size)
                 {
-                    priv_size = subtitle->extradata_size;
+                    priv_size = subtitle->extradata->size;
                     priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                    memcpy(priv_data, subtitle->extradata, priv_size);
+                    memcpy(priv_data, subtitle->extradata->bytes, priv_size);
                 }
             } break;
 
@@ -1072,16 +856,16 @@ static int avformatInit( hb_mux_object_t * m )
                     track->st->codecpar->codec_id = AV_CODEC_ID_ASS;
                     need_fonts = 1;
 
-                    if (subtitle->extradata_size)
+                    if (subtitle->extradata && subtitle->extradata->size)
                     {
-                        priv_size = subtitle->extradata_size;
+                        priv_size = subtitle->extradata->size;
                         priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                         if (priv_data == NULL)
                         {
                             hb_error("SSA extradata: malloc failure");
                             goto error;
                         }
-                        memcpy(priv_data, subtitle->extradata, priv_size);
+                        memcpy(priv_data, subtitle->extradata->bytes, priv_size);
                     }
                 }
             } break;
@@ -1205,8 +989,8 @@ static int avformatInit( hb_mux_object_t * m )
                     av_dict_set(&st->metadata, "mimetype", "application/vnd.ms-opentype", 0);
                 }
 
-                priv_size = attachment->size;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
+                size_t   priv_size = attachment->size;
+                uint8_t *priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("Font extradata: malloc failure");
@@ -1687,24 +1471,7 @@ static int avformatEnd(hb_mux_object_t *m)
         {
             case HB_ACODEC_FFFLAC:
             case HB_ACODEC_FFFLAC24:
-                if( audio->priv.config.extradata.length )
-                {
-                    uint8_t *priv_data;
-                    int priv_size;
-
-                    priv_size = audio->priv.config.extradata.length;
-                    priv_data = av_realloc(st->codecpar->extradata, priv_size +
-                                           AV_INPUT_BUFFER_PADDING_SIZE);
-                    if (priv_data == NULL)
-                    {
-                        break;
-                    }
-                    memcpy(priv_data,
-                           audio->priv.config.extradata.bytes,
-                           audio->priv.config.extradata.length);
-                    st->codecpar->extradata = priv_data;
-                    st->codecpar->extradata_size = priv_size;
-                }
+                set_extradata(audio->priv.extradata, &st->codecpar->extradata, &st->codecpar->extradata_size);
                 break;
             default:
                 break;
diff --git a/libhb/platform/macosx/encca_aac.c b/libhb/platform/macosx/encca_aac.c
index a9b377d2e..f0a85d4d5 100644
--- a/libhb/platform/macosx/encca_aac.c
+++ b/libhb/platform/macosx/encca_aac.c
@@ -10,6 +10,8 @@
 #include "handbrake/handbrake.h"
 #include "handbrake/audio_remap.h"
 #include "handbrake/hbffmpeg.h"
+#include "handbrake/extradata.h"
+
 #include <AudioToolbox/AudioToolbox.h>
 #include <CoreAudio/CoreAudio.h>
 
@@ -313,15 +315,16 @@ int encCoreAudioInit(hb_work_object_t *w, hb_job_t *job, enum AAC_MODE mode)
 
     // get magic cookie (elementary stream descriptor)
     tmp = HB_CONFIG_MAX_SIZE;
+    UInt8 *magicCookie[HB_CONFIG_MAX_SIZE];
     AudioConverterGetProperty(pv->converter,
                               kAudioConverterCompressionMagicCookie,
-                              &tmp, w->config->extradata.bytes);
+                              &tmp, magicCookie);
     // CoreAudio returns a complete ESDS, but we only need
     // the DecoderSpecific info.
-    UInt8* buffer = NULL;
-    ReadESDSDescExt(w->config->extradata.bytes, &buffer, &tmpsiz, 0);
-    w->config->extradata.length = tmpsiz;
-    memmove(w->config->extradata.bytes, buffer, w->config->extradata.length);
+    UInt8 *buffer = NULL;
+    ReadESDSDescExt(magicCookie, &buffer, &tmpsiz, 0);
+
+    hb_set_extradata(w->extradata, buffer, tmpsiz);
     free(buffer);
 
     AudioConverterPrimeInfo primeInfo;
@@ -332,7 +335,7 @@ int encCoreAudioInit(hb_work_object_t *w, hb_job_t *job, enum AAC_MODE mode)
                               &piSize, &primeInfo);
 
     pv->delay = primeInfo.leadingFrames * 90000LL / pv->osamplerate;
-    w->config->init_delay = pv->delay;
+    *w->init_delay = pv->delay;
 
     pv->list = hb_list_init();
     pv->buf = NULL;
diff --git a/libhb/platform/macosx/encvt.c b/libhb/platform/macosx/encvt.c
index 984b67bc0..7fded81d7 100644
--- a/libhb/platform/macosx/encvt.c
+++ b/libhb/platform/macosx/encvt.c
@@ -15,6 +15,8 @@
 #include "handbrake/handbrake.h"
 #include "handbrake/hdr10plus.h"
 #include "handbrake/hbffmpeg.h"
+#include "handbrake/nal_units.h"
+#include "handbrake/extradata.h"
 #include "cv_utils.h"
 
 int  encvt_init(hb_work_object_t *, hb_job_t *);
@@ -211,7 +213,7 @@ static void compute_dts_offset(hb_work_private_t *pv, hb_buffer_t *buf)
         if ((pv->frameno_in) == pv->job->areBframes)
         {
             pv->dts_delay = buf->s.start;
-            pv->job->config.init_delay = pv->dts_delay;
+            pv->job->init_delay = pv->dts_delay;
         }
     }
 }
@@ -1201,31 +1203,40 @@ static void set_h264_cookie(hb_work_object_t *w, CMFormatDescriptionRef format)
 
         const uint8_t *avcCAtom = CFDataGetBytePtr(magicCookie);
 
-        SInt64 i;
+        uint8_t sps[HB_CONFIG_MAX_SIZE];
+        size_t sps_length = 0;
+        uint8_t pps[HB_CONFIG_MAX_SIZE];
+        size_t pps_length = 0;
+
         int8_t spsCount = (avcCAtom[5] & 0x1f);
         uint8_t ptrPos = 6;
         uint8_t spsPos = 0;
-        for (i = 0; i < spsCount; i++) {
+        for (SInt64 i = 0; i < spsCount; i++) {
             uint16_t spsSize = (avcCAtom[ptrPos++] << 8) & 0xff00;
             spsSize += avcCAtom[ptrPos++] & 0xff;
-            memcpy(w->config->h264.sps + spsPos, avcCAtom+ptrPos, spsSize);;
+            memcpy(sps + spsPos, avcCAtom+ptrPos, spsSize);;
             ptrPos += spsSize;
             spsPos += spsSize;
         }
-        w->config->h264.sps_length = spsPos;
+        sps_length = spsPos;
 
         int8_t ppsCount = avcCAtom[ptrPos++];
         uint8_t ppsPos = 0;
-        for (i = 0; i < ppsCount; i++)
+        for (SInt64 i = 0; i < ppsCount; i++)
         {
             uint16_t ppsSize = (avcCAtom[ptrPos++] << 8) & 0xff00;
             ppsSize += avcCAtom[ptrPos++] & 0xff;
-            memcpy(w->config->h264.pps + ppsPos, avcCAtom+ptrPos, ppsSize);;
+            memcpy(pps + ppsPos, avcCAtom+ptrPos, ppsSize);;
 
             ptrPos += ppsSize;
             ppsPos += ppsSize;
         }
-        w->config->h264.pps_length = ppsPos;
+        pps_length = ppsPos;
+
+        if (hb_set_h264_extradata(w->extradata, sps, sps_length, pps, pps_length))
+        {
+            hb_log("VTCompressionSession: Set extradata error");
+        }
     }
 }
 
@@ -1247,8 +1258,7 @@ static void set_h265_cookie(hb_work_object_t *w, CMFormatDescriptionRef format)
 
         const uint8_t *hvcCAtom = CFDataGetBytePtr(magicCookie);
         uint16_t size = CFDataGetLength(magicCookie);
-        memcpy(w->config->h265.headers, hvcCAtom, size);
-        w->config->h265.headers_length = size;
+        hb_set_extradata(w->extradata, hvcCAtom, size);
     }
 }
 
diff --git a/libhb/rendersub.c b/libhb/rendersub.c
index 6907d79cf..a3297c4b6 100644
--- a/libhb/rendersub.c
+++ b/libhb/rendersub.c
@@ -9,6 +9,7 @@
 
 #include "handbrake/handbrake.h"
 #include "handbrake/hbffmpeg.h"
+#include "handbrake/extradata.h"
 #include "libavutil/bswap.h"
 #include <ass/ass.h>
 
@@ -915,8 +916,8 @@ static int ssa_work( hb_filter_object_t * filter,
         // decoder initialization happens after filter initialization,
         // we need to postpone this.
         ass_process_codec_private(pv->ssaTrack,
-                                  (char*)filter->subtitle->extradata,
-                                  filter->subtitle->extradata_size);
+                                  (char *)filter->subtitle->extradata->bytes,
+                                  filter->subtitle->extradata->size);
         pv->script_initialized = 1;
     }
     if (in->s.flags & HB_BUF_FLAG_EOF)
@@ -959,8 +960,8 @@ static int cc608sub_post_init( hb_filter_object_t * filter, hb_job_t * job )
     int width = job->title->geometry.width - job->crop[2] - job->crop[3];
     int safe_height = 0.8 * job->title->geometry.height;
     // Use fixed width font for CC
-    hb_subtitle_add_ssa_header(filter->subtitle, HB_FONT_MONO,
-                               .08 * safe_height, width, height);
+    hb_set_ssa_extradata(&filter->subtitle->extradata, HB_FONT_MONO,
+                         .08 * safe_height, width, height);
     return ssa_post_init(filter, job);
 }
 
@@ -970,9 +971,9 @@ static int textsub_post_init( hb_filter_object_t * filter, hb_job_t * job )
     // to have the header rewritten with the correct dimensions.
     int height = job->title->geometry.height - job->crop[0] - job->crop[1];
     int width = job->title->geometry.width - job->crop[2] - job->crop[3];
-    hb_subtitle_add_ssa_header(filter->subtitle, HB_FONT_SANS,
-                               .066 * job->title->geometry.height,
-                               width, height);
+    hb_set_ssa_extradata(&filter->subtitle->extradata, HB_FONT_SANS,
+                         .066 * job->title->geometry.height,
+                         width, height);
     return ssa_post_init(filter, job);
 }
 
@@ -1017,8 +1018,8 @@ static int textsub_work(hb_filter_object_t * filter,
     if (!pv->script_initialized)
     {
         ass_process_codec_private(pv->ssaTrack,
-                                  (char*)filter->subtitle->extradata,
-                                  filter->subtitle->extradata_size);
+                                  (char*)filter->subtitle->extradata->bytes,
+                                  filter->subtitle->extradata->size);
         pv->script_initialized = 1;
     }
 
diff --git a/libhb/stream.c b/libhb/stream.c
index 235954708..62f5e196e 100644
--- a/libhb/stream.c
+++ b/libhb/stream.c
@@ -14,6 +14,7 @@
 #include "handbrake/handbrake.h"
 #include "handbrake/hbffmpeg.h"
 #include "handbrake/lang.h"
+#include "handbrake/extradata.h"
 #include "libbluray/bluray.h"
 
 #define min(a, b) a < b ? a : b
@@ -2001,10 +2002,9 @@ static void pes_add_subtitle_to_title(
                     subtitle->config.dest = RENDERSUB;
                     if (pes->extradata != NULL)
                     {
-                        subtitle->extradata = malloc(pes->extradata_size);
-                        subtitle->extradata_size = pes->extradata_size;
-                        memcpy(subtitle->extradata, pes->extradata,
-                                                    pes->extradata_size);
+                        hb_set_extradata(&subtitle->extradata,
+                                         pes->extradata,
+                                         pes->extradata_size);
                     }
                     break;
                 case AV_CODEC_ID_HDMV_PGS_SUBTITLE:
@@ -5390,14 +5390,12 @@ static void add_ffmpeg_audio(hb_title_t *title, hb_stream_t *stream, int id)
     {
         case AV_CODEC_ID_AAC:
         {
-            int len = MIN(codecpar->extradata_size, HB_CONFIG_MAX_SIZE);
-            memcpy(audio->priv.config.extradata.bytes, codecpar->extradata, len);
-            audio->priv.config.extradata.length = len;
-            audio->config.in.codec              = HB_ACODEC_FFAAC;
+            hb_set_extradata(&audio->priv.extradata, codecpar->extradata, codecpar->extradata_size);
+            audio->config.in.codec = HB_ACODEC_FFAAC;
         } break;
 
         case AV_CODEC_ID_AC3:
-            audio->config.in.codec       = HB_ACODEC_AC3;
+            audio->config.in.codec = HB_ACODEC_AC3;
             break;
 
         case AV_CODEC_ID_EAC3:
@@ -5433,10 +5431,8 @@ static void add_ffmpeg_audio(hb_title_t *title, hb_stream_t *stream, int id)
 
         case AV_CODEC_ID_FLAC:
         {
-            int len = MIN(codecpar->extradata_size, HB_CONFIG_MAX_SIZE);
-            memcpy(audio->priv.config.extradata.bytes, codecpar->extradata, len);
-            audio->priv.config.extradata.length = len;
-            audio->config.in.codec              = HB_ACODEC_FFFLAC;
+            hb_set_extradata(&audio->priv.extradata, codecpar->extradata, codecpar->extradata_size);
+            audio->config.in.codec = HB_ACODEC_FFFLAC;
         } break;
 
         case AV_CODEC_ID_MP2:
@@ -5449,10 +5445,8 @@ static void add_ffmpeg_audio(hb_title_t *title, hb_stream_t *stream, int id)
 
         case AV_CODEC_ID_OPUS:
         {
-            int len = MIN(codecpar->extradata_size, HB_CONFIG_MAX_SIZE);
-            memcpy(audio->priv.config.extradata.bytes, codecpar->extradata, len);
-            audio->priv.config.extradata.length = len;
-            audio->config.in.codec              = HB_ACODEC_OPUS;
+            hb_set_extradata(&audio->priv.extradata, codecpar->extradata, codecpar->extradata_size);
+            audio->config.in.codec = HB_ACODEC_OPUS;
         } break;
 
         default:
@@ -5694,11 +5688,7 @@ static void add_ffmpeg_subtitle( hb_title_t *title, hb_stream_t *stream, int id
     // Copy the extradata for the subtitle track
     if (codecpar->extradata != NULL)
     {
-        subtitle->extradata = malloc(codecpar->extradata_size + 1);
-        memcpy(subtitle->extradata,
-               codecpar->extradata, codecpar->extradata_size);
-        subtitle->extradata[codecpar->extradata_size] = 0;
-        subtitle->extradata_size = codecpar->extradata_size + 1;
+        hb_set_text_extradata(&subtitle->extradata, codecpar->extradata, codecpar->extradata_size);
     }
 
     if (st->disposition & AV_DISPOSITION_DEFAULT)
diff --git a/libhb/work.c b/libhb/work.c
index 2795f597d..14b8cf398 100644
--- a/libhb/work.c
+++ b/libhb/work.c
@@ -1205,10 +1205,6 @@ static int sanitize_audio(hb_job_t *job)
             continue;
         }
 
-        /* Vorbis language information */
-        if (audio->config.out.codec == HB_ACODEC_VORBIS)
-            audio->priv.config.vorbis.language = audio->config.lang.simple;
-
         /* sense-check the requested samplerate */
         if (audio->config.out.samplerate <= 0)
         {
@@ -1854,9 +1850,10 @@ static void do_job(hb_job_t *job)
                 *job->die = 1;
                 goto cleanup;
             }
+            w->init_delay = &audio->priv.init_delay;
+            w->extradata  = &audio->priv.extradata;
             w->fifo_in  = audio->priv.fifo_in;
             w->fifo_out = audio->priv.fifo_raw;
-            w->config   = &audio->priv.config;
             w->audio    = audio;
             w->codec_param = audio->config.in.codec_param;
 
@@ -1941,9 +1938,10 @@ static void do_job(hb_job_t *job)
                     *job->die = 1;
                     goto cleanup;
                 }
+                w->init_delay = &audio->priv.init_delay;
+                w->extradata  = &audio->priv.extradata;
                 w->fifo_in  = audio->priv.fifo_sync;
                 w->fifo_out = audio->priv.fifo_out;
-                w->config   = &audio->priv.config;
                 w->audio    = audio;
 
                 hb_list_add( job->list_work, w );
@@ -1988,8 +1986,10 @@ static void do_job(hb_job_t *job)
         else
             w->fifo_in  = job->fifo_sync;
 
-        w->fifo_out = job->fifo_mpeg4;
-        w->config   = &job->config;
+        w->fifo_out  =  job->fifo_mpeg4;
+
+        w->init_delay = &job->init_delay;
+        w->extradata  = &job->extradata;
 
         hb_list_add( job->list_work, w );
 
-- 
2.34.1

